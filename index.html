<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>画像 → ボクセルOBJ変換ツール</title>
  <style>
    body {
      background: #222;
      color: #eee;
      font-family: sans-serif;
      text-align: center;
      padding: 20px;
    }
    canvas {
      background: #000;
      margin-top: 10px;
    }
    input {
      margin: 5px;
    }
  </style>
</head>
<body>
  <h2>画像 → ボクセルOBJ変換ツール</h2>
  <input type="file" id="imageLoader" accept="image/*"><br>
  横: <input type="number" id="scaleX" value="1" step="0.1">
  縦: <input type="number" id="scaleY" value="1" step="0.1">
  厚み: <input type="number" id="scaleZ" value="1" step="0.1">
  <button id="exportBtn">OBJ保存</button><br>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let imageData = null;
    let pixelData = [];
    let objData = "";

    document.getElementById('imageLoader').addEventListener('change', handleImage);
    document.getElementById('exportBtn').addEventListener('click', exportOBJ);

    function handleImage(e) {
      const reader = new FileReader();
      reader.onload = function (event) {
        const img = new Image();
        img.onload = function () {
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);
          imageData = ctx.getImageData(0, 0, img.width, img.height);
          drawPreview();
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    }

    function drawPreview() {
      const { width, height, data } = imageData;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // スケーリングして画面に収まるように調整
      const scale = Math.min(600 / width, 600 / height);
      canvas.width = width * scale;
      canvas.height = height * scale;
      ctx.imageSmoothingEnabled = false;

      pixelData = []; // リセット
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const i = (y * width + x) * 4;
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const a = data[i + 3];
          if (a > 0) {
            pixelData.push({ x, y, color: { r, g, b } });
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(x * scale, y * scale, scale, scale);
          }
        }
      }
    }

    function exportOBJ() {
      const sx = parseFloat(document.getElementById('scaleX').value);
      const sy = parseFloat(document.getElementById('scaleY').value);
      const sz = parseFloat(document.getElementById('scaleZ').value);

      let obj = "";
      let vertexOffset = 1;

      for (const p of pixelData) {
        const { x, y, color } = p;
        const cx = x * sx;
        const cy = -y * sy;
        const cz = 0;

        const w = sx / 2;
        const h = sy / 2;
        const d = sz / 2;

        // 8頂点
        const v = [
          [cx - w, cy - h, cz - d],
          [cx + w, cy - h, cz - d],
          [cx + w, cy + h, cz - d],
          [cx - w, cy + h, cz - d],
          [cx - w, cy - h, cz + d],
          [cx + w, cy - h, cz + d],
          [cx + w, cy + h, cz + d],
          [cx - w, cy + h, cz + d]
        ];

        for (const vert of v) {
          obj += `v ${vert[0]} ${vert[1]} ${vert[2]}\n`;
        }

        // 6面 (f1〜f6)
        const faces = [
          [1, 2, 3, 4],
          [5, 6, 7, 8],
          [1, 5, 8, 4],
          [2, 6, 7, 3],
          [4, 3, 7, 8],
          [1, 2, 6, 5]
        ];

        for (const f of faces) {
          obj += `f ${f.map(i => i + vertexOffset - 1).join(' ')}\n`;
        }

        vertexOffset += 8;
      }

      downloadTextFile("voxel.obj", obj);
    }

    function downloadTextFile(filename, text) {
      const blob = new Blob([text], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();
    }
  </script>
</body>
</html>
